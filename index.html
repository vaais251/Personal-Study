<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pomodoro Study Timer</title>
    <!-- NEW: Added a dynamic SVG favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 100 100%27><circle cx=%2750%27 cy=%2750%27 r=%2745%27 fill=%27%23f5576c%27/><circle cx=%2750%27 cy=%2750%27 r=%2730%27 fill=%27white%27/><circle cx=%2750%27 cy=%2750%27 r=%2715%27 fill=%27%23f5576c%27/></svg>">
    <!-- NEW: Added Chart.js for stats -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Aligned to top for scrolling */
            overflow-y: auto; /* Allow scrolling for more content */
            padding: 40px 0;
            /* GUI UPDATE: Smooth background transitions */
            transition: background 1s ease;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 30px;
            padding: 40px;
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 550px;
            width: 90%;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: white;
            font-size: 32px;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .session-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .info-value {
            color: white;
            font-size: 24px;
            font-weight: 600;
        }

        .mode-indicator {
            text-align: center;
            margin-bottom: 20px;
        }

        .mode-badge {
            display: inline-block;
            padding: 10px 30px;
            border-radius: 20px;
            color: white;
            font-weight: 600;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
        }

        .mode-badge.focus {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            animation: pulse 2s ease-in-out infinite;
        }

        .mode-badge.break {
            background: linear-gradient(135deg, #a8e063 0%, #56ab2f 100%);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }

        .display {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        .progress-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .progress-ring circle {
            stroke: white;
            stroke-width: 8;
            fill: transparent;
            stroke-dasharray: 565;
            stroke-dashoffset: 565;
            transition: stroke-dashoffset 1s linear;
            opacity: 0.3;
        }

        .time-display {
            font-size: 96px;
            font-weight: 300;
            color: white;
            letter-spacing: 2px;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            font-variant-numeric: tabular-nums;
            line-height: 1;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: white;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::before {
            width: 100%;
            height: 100%;
        }

        .btn-start {
            background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
            box-shadow: 0 10px 25px rgba(58, 123, 213, 0.4);
        }

        .btn-start:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(58, 123, 213, 0.5);
        }

        .btn-stop {
            background: linear-gradient(135deg, #f857a6 0%, #ff5858 100%);
            box-shadow: 0 10px 25px rgba(255, 88, 88, 0.4);
        }

        .btn-stop:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(255, 88, 88, 0.5);
        }

        .btn-reset {
            background: linear-gradient(135deg, #ffd89b 0%, #ffaa00 100%);
            box-shadow: 0 10px 25px rgba(255, 170, 0, 0.4);
        }

        .btn-reset:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(255, 170, 0, 0.5);
        }

        .btn-settings {
            background: linear-gradient(135deg, #a8e063 0%, #56ab2f 100%);
            box-shadow: 0 10px 25px rgba(86, 171, 47, 0.4);
        }

        .btn-settings:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(86, 171, 47, 0.5);
        }

        .btn svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        .btn span {
            font-size: 12px;
            margin-top: 5px;
        }

        /* Common panel style */
        .settings-panel, .task-manager, .history-panel, .ai-panel {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .settings-panel.hidden {
            display: none;
        }

        .panel-title {
            color: white;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .panel-subtitle {
            color: white;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 20px;
            margin-top: 25px;
        }

        .setting-group, .task-input-group, .history-input-group {
            margin-bottom: 20px;
        }

        .setting-label {
            color: white;
            font-size: 14px;
            margin-bottom: 8px;
            display: block;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Common input style */
        .setting-input, .task-input, #historyDate, #taskPoms,
        #historyStartDate, #historyEndDate, #sessionComment, #taskPomsTomorrow {
            flex: 1;
            padding: 12px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 16px;
        }
        
        input[type="date"] {
            color-scheme: dark;
        }
        .setting-input, #taskPoms, #taskPomsTomorrow { text-align: center; }

        #taskPoms, #taskPomsTomorrow {
            flex: 0 1 90px;
            -moz-appearance: textfield;
        }
        #taskPoms::placeholder, #taskPomsTomorrow::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        #taskPoms::-webkit-inner-spin-button,
        #taskPoms::-webkit-outer-spin-button,
        #taskPomsTomorrow::-webkit-inner-spin-button,
        #taskPomsTomorrow::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }


        .setting-input::placeholder, .task-input::placeholder, #sessionComment::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .setting-input:focus, .task-input:focus, #historyDate:focus, #taskPoms:focus,
        #historyStartDate:focus, #historyEndDate:focus, #sessionComment:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .setting-unit {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            min-width: 60px;
        }

        /* Common button style */
        .panel-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .panel-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(58, 123, 213, 0.5);
        }
        
        #getInsightsBtn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .add-task-btn { /* Specific for small buttons next to inputs */
            padding: 12px 20px;
            background: linear-gradient(135deg, #a8e063 0%, #56ab2f 100%);
            border-radius: 10px;
            border: none; 
            color: white; 
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .add-task-btn:hover {
            transform: scale(1.05);
        }
        
        /* NEW: Button style for tomorrow's task add */
        .add-task-tomorrow-btn {
            padding: 12px 20px;
            background: linear-gradient(135deg, #ffd89b 0%, #ffaa00 100%);
            border-radius: 10px;
            border: none; 
            color: white; 
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .add-task-tomorrow-btn:hover {
             transform: scale(1.05);
        }


        /* Task List styles */
        #taskList, #taskListTomorrow {
            list-style: none;
            padding: 0;
            max-height: 250px;
            overflow-y: auto;
            overflow-x: hidden; /* Fixes hover scrollbar issue */
        }

        #taskEmptyState, #taskTomorrowEmptyState {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            padding: 20px 0;
            display: none; /* Hidden by default */
        }
        
        /* Style for "Tomorrow" panel task items */
        /* UI FIX: Changed from dark bg to light bg */
        #taskListTomorrow .task-item {
             background: rgba(255, 255, 255, 0.05);
             border: 1px dashed rgba(255, 216, 155, 0.3);
        }

        .task-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            color: white;
            cursor: grab;
            transition: all 0.2s ease-out;
        }
        .task-item:last-child { margin-bottom: 0; }
        .task-item.dragging { opacity: 0.5; background: rgba(255,255,255,0.3); }

        .task-item:not(.completed):hover {
            transform: scale(1.02);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* UI FIX: Hover for tomorrow's tasks */
        #taskListTomorrow .task-item:hover {
            background: rgba(255, 216, 155, 0.2);
        }

        .task-item-details {
            display: flex;
            align-items: center;
            flex-grow: 1;
            margin-left: 10px;
            word-break: break-word; /* Wrap long text */
        }

        .task-pom-count {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            padding: 2px 6px;
            font-size: 12px;
            margin-left: auto; /* Pushes it to the right */
            margin-right: 10px;
            flex-shrink: 0; /* Prevent shrinking */
        }
        
        #taskListTomorrow .task-pom-count {
            background: rgba(255, 216, 155, 0.2);
            color: #ffd89b;
        }
        
        .task-handle {
            cursor: grab;
            color: rgba(255,255,255,0.7);
            padding: 0 5px;
        }

        /* NEW: Common icon button style */
        .task-btn {
            background: none; 
            border: none; 
            cursor: pointer; 
            font-size: 20px;
            padding: 0 5px;
            transition: all 0.3s;
            flex-shrink: 0;
            fill: white;
            width: 20px;
            height: 20px;
            margin-left: 5px;
        }

        .delete-task-btn {
            color: #ff5858;
        }
        .delete-task-btn:hover {
            color: #f857a6;
            transform: scale(1.1);
        }
        
        /* NEW: Postpone/Duplicate button styles */
        .postpone-task-btn, .duplicate-task-btn {
            fill: #ffd89b;
        }
        .postpone-task-btn:hover, .duplicate-task-btn:hover {
            fill: #ffaa00;
            transform: scale(1.1);
        }

        /* Style for completed tasks */
        .task-item.completed {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.5);
            cursor: default;
        }

        .task-item.completed .task-item-text {
            text-decoration: line-through;
        }
        
        .task-item.completed .task-pom-count {
            background: rgba(0, 0, 0, 0.2);
        }

        .task-item.completed .task-handle,
        .task-item.completed .delete-task-btn,
        .task-item.completed .postpone-task-btn, /* NEW: Hide on completed */
        .task-item.completed .duplicate-task-btn { /* NEW: Hide on completed */
            display: none; 
        }
        
        /* Hide postpone/duplicate on tomorrow's list */
        #taskListTomorrow .task-item .postpone-task-btn,
        #taskListTomorrow .task-item .duplicate-task-btn,
        #taskListTomorrow .task-item .task-handle {
            display: none;
        }
        
        /* UI FIX: Align tomorrow's task details */
        #taskListTomorrow .task-item-details {
            margin-left: 0;
        }
        
        /* History Panel styles */
        #historyDisplay {
            margin-top: 20px;
            color: white;
            background: rgba(0,0,0,0.1);
            border-radius: 8px;
            padding: 15px;
            min-height: 50px;
        }
        #historyDisplay h4 { margin-bottom: 10px; }
        #historyDisplay ul { list-style-position: inside; padding-left: 10px; }
        #historyDisplay li { margin-bottom: 5px; }
        #historyDisplay .comment-list {
            list-style-type: square;
            margin-left: 20px;
            margin-top: 5px;
            color: rgba(255, 255, 255, 0.8);
        }
        #historyDisplay .comment-list li {
            font-style: italic;
            font-size: 14px;
        }


        /* Stats panel */
        .stats {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .stats-title {
            color: white;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: white;
            font-size: 24px;
            font-weight: 600;
        }
        
        .chart-container {
            margin-top: 25px;
            position: relative;
            height: 200px; /* Give canvas a set height */
        }
        
        #historyStatsMessage {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        /* NEW: AI Insights Display */
        #aiInsightsDisplay {
            margin-top: 20px;
            color: white;
            background: rgba(0,0,0,0.1);
            border-radius: 8px;
            padding: 15px;
            min-height: 100px;
            line-height: 1.6;
        }
        
        #aiInsightsDisplay strong {
            color: #f093fb;
        }
        #aiInsightsDisplay ul {
            margin-top: 10px;
            margin-bottom: 10px;
            padding-left: 20px;
        }
        #aiInsightsDisplay li {
            margin-bottom: 5px;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-left-color: #f093fb;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Modal Styles */
        .modal-overlay {
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0;
            width: 100%; 
            height: 100%; 
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000; 
            justify-content: center; 
            align-items: center;
            animation: fadeIn 0.3s ease;
        }
        .modal-overlay.show { 
            display: flex; 
        }
        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px; 
            padding: 40px; 
            max-width: 400px; 
            width: 90%;
            text-align: center; 
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.4s ease;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { opacity: 0; transform: translateY(50px); } to { opacity: 1; transform: translateY(0); } }
        .modal-icon { 
            font-size: 64px; 
            margin-bottom: 20px; 
            animation: bounce 1s ease infinite; 
        }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        .modal-title { 
            color: white; 
            font-size: 28px; 
            font-weight: 600; 
            margin-bottom: 15px; 
        }
        .modal-message { 
            color: rgba(255, 255, 255, 0.9); 
            font-size: 18px; 
            margin-bottom: 30px; 
            line-height: 1.5; 
        }
        
        #sessionComment {
            display: none; /* Hidden by default */
            margin: -10px 0 20px 0;
            height: 80px;
            text-align: left;
            font-size: 14px;
            padding: 10px;
            resize: vertical;
            flex: none; /* Override common input style */
        }

        .modal-btn {
            width: 100%; 
            padding: 18px; 
            background: white; 
            border: none;
            border-radius: 12px; 
            color: #667eea; 
            font-size: 18px; 
            font-weight: 700;
            cursor: pointer; 
            transition: all 0.3s; 
            text-transform: uppercase; 
            letter-spacing: 1px;
        }
        .modal-btn:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3); 
        }
        
        /* Hide number input spinners for a cleaner look */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button { 
            -webkit-appearance: none;
            margin: 0; 
        }
        input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Study Timer</h1>
        </div>

        <!-- Timer Status Info -->
        <div class="session-info">
            <div class="info-item">
                <div class="info-label">Sessions</div>
                <div class="info-value" id="sessionCount">1/2</div>
            </div>
            <div class="info-item">
                <div class="info-label">Completed</div>
                <div class="info-value" id="completedSessions">0</div>
            </div>
        </div>

        <!-- Mode Indicator -->
        <div class="mode-indicator">
            <div class="mode-badge focus" id="modeBadge">Focus Time</div>
        </div>

        <!-- Timer Display -->
        <div class="display">
            <svg class="progress-ring" width="180" height="180">
                <circle cx="90" cy="90" r="90" id="progressCircle"></circle>
            </svg>
            <div class="time-display" id="display">25:00</div>
        </div>

        <!-- Timer Controls -->
        <div class="controls">
            <button class="btn btn-start" id="startBtn">
                <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                <span>START</span>
            </button>
            <button class="btn btn-stop" id="stopBtn" style="display: none;">
                <svg viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                <span>PAUSE</span>
            </button>
            <button class="btn btn-reset" id="resetBtn">
                <svg viewBox="0 0 24 24"><path d="M4 12a8 8 0 0 1 8-8V2.5L16 6l-4 3.5V8a6 6 0 1 0 6 6h1.5a7.5 7.5 0 1 1-7.5-7.5z"/></svg>
                <span>RESET</span>
            </button>
            <button class="btn btn-settings" id="settingsBtn">
                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m4.22-13.22l-4.22 4.22m0 6l4.22 4.22M20 12h-6m-6 0H2m13.22 4.22l-4.22-4.22m-6 0l-4.22 4.22"></path></svg>
                <span>SETTINGS</span>
            </button>
        </div>

        <!-- Today's Task Manager Panel -->
        <div class="task-manager" id="taskManager">
            <div class="panel-title">üìù Today's Tasks</div>
            <div class="task-input-group">
                <div class="input-group">
                    <input type="text" id="taskInput" class="task-input" placeholder="Enter a new task...">
                    <input type="number" id="taskPoms" min="1" max="10" placeholder="Poms">
                    <button id="addTaskBtn" class="add-task-btn">Add</button>
                </div>
            </div>
            <ul id="taskList">
                <!-- Tasks will be dynamically added here -->
            </ul>
            <div id="taskEmptyState">
                All done! Add a new task to get started.
            </div>
        </div>
        
        <!-- NEW: Tomorrow's Task Manager Panel -->
        <div class="task-manager" id="tomorrowTaskManager">
            <div class="panel-title">üóìÔ∏è Tomorrow's Tasks</div>
            <div class="task-input-group">
                <div class="input-group">
                    <input type="text" id="taskInputTomorrow" class="task-input" placeholder="Plan a task for tomorrow...">
                    <input type="number" id="taskPomsTomorrow" min="1" max="10" placeholder="Poms">
                    <button id="addTaskTomorrowBtn" class="add-task-tomorrow-btn">Add</button>
                </div>
            </div>
            <ul id="taskListTomorrow">
                <!-- Tomorrow's tasks will be dynamically added here -->
            </ul>
            <div id="taskTomorrowEmptyState">
                No tasks planned for tomorrow.
            </div>
        </div>
        
        <!-- Timer Settings Panel -->
        <div class="settings-panel hidden" id="settingsPanel">
            <div class="panel-title">‚öôÔ∏è Timer Settings</div>
            <div class="setting-group">
                <label class="setting-label">Focus Duration</label>
                <div class="input-group">
                    <input type="number" class="setting-input" id="focusTime" value="25" min="1" max="120">
                    <span class="setting-unit">minutes</span>
                </div>
            </div>
            <div class="setting-group">
                <label class="setting-label">Break Duration</label>
                <div class="input-group">
                    <input type="number" class="setting-input" id="breakTime" value="5" min="1" max="60">
                    <span class="setting-unit">minutes</span>
                </div>
            </div>
            <div class="setting-group">
                <label class="setting-label">Sessions per Cycle</label>
                <div class="input-group">
                    <input type="number" class="setting-input" id="sessionsPerCycle" value="2" min="1" max="10">
                    <span class="setting-unit">sessions</span>
                </div>
            </div>
            <button class="panel-btn" id="saveBtn">üíæ Save Settings</button>
        </div>
        
        <!-- History & Data Panel -->
        <div class="history-panel" id="historyPanel">
            <div class="panel-title">üìú Task History</div>

            <!-- Historical Progress Section -->
            <div class="panel-subtitle" style="margin-top: 0; border-top: none; padding-top: 0;">Historical Progress</div>
            <div class="history-input-group">
                <div class="input-group">
                    <input type="date" id="historyStartDate" class="setting-input">
                    <span style="color: white;">to</span>
                    <input type="date" id="historyEndDate" class="setting-input">
                </div>
            </div>
            <div id="historyStatsMessage"></div>
            
            <!-- Historical Stats Grid -->
            <div class="stats-grid" style="margin-top: 20px;">
                <div class="stat-item">
                    <div class="stat-label">Focus Time</div>
                    <div class="stat-value" id="histStatFocusTime">0m</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Sessions Done</div>
                    <div class="stat-value" id="histStatSessions">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Completion %</div>
                    <div class="stat-value" id="histStatCompletion">0%</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Tasks</div>
                    <div class="stat-value" id="histStatTotalTasks">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Poms Done</div>
                    <div class="stat-value" id="histStatPomsDone">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Poms Estimated</div>
                    <div class="stat-value" id="histStatPomsEst">0</div>
                </div>
            </div>
            
            <!-- Historical Chart Container -->
            <div class="chart-container">
                <canvas id="historyTaskChart"></canvas>
            </div>

            <!-- Single Day Log Viewer -->
            <div class="panel-subtitle">Single Day Log</div>
            <div class="history-input-group">
                <label class="setting-label">View Log for a Specific Day</label>
                <div class="input-group">
                    <input type="date" id="historyDate" class="setting-input">
                    <button id="viewHistoryBtn" class="add-task-btn">View</button>
                </div>
                <div id="historyDisplay"></div>
            </div>
            
            <button class="panel-btn" id="downloadLogBtn">üìÑ Download Today's Log</button>
            <button class="panel-btn" id="downloadWeeklyLogBtn" style="background: linear-gradient(135deg, #ffd89b 0%, #ffaa00 100%); margin-top: 15px;">üóìÔ∏è Download Weekly Summary</button>
        </div>

        <!-- Today's Stats Panel -->
        <div class="stats">
            <div class="stats-title">üìä Today's Progress</div>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Focus Time</div>
                    <div class="stat-value" id="totalFocusTime">0m</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Sessions Done</div>
                    <div class="stat-value" id="totalSessions">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Completion %</div>
                    <div class="stat-value" id="statCompletion">0%</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Tasks</div>
                    <div class="stat-value" id="statTotalTasks">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Poms Done</div>
                    <div class="stat-value" id="statPomsDone">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Poms Estimated</div>
                    <div class="stat-value" id="statPomsEst">0</div>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="taskChart"></canvas>
            </div>
        </div>
        
        <!-- AI Insights Panel -->
        <div class="ai-panel">
            <div class="panel-title">ü§ñ AI Study Insights</div>
            <p style="color: rgba(255,255,255,0.8); text-align: center; font-size: 14px; margin-bottom: 20px;">
                Get AI-powered insights on your study habits based on the dates selected in the "Historical Progress" panel.
            </p>
            <button class="panel-btn" id="getInsightsBtn">Get AI Insights for Selected Range</button>
            <div id="aiInsightsDisplay">
                Click the button to get your insights!
            </div>
        </div>
    </div>

    <!-- Modal for phase completion -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content">
            <div class="modal-icon" id="modalIcon">‚è∞</div>
            <div class="modal-title" id="modalTitle">Time's Up!</div>
            <div class="modal-message" id="modalMessage">Ready to continue?</div>
            <textarea id="sessionComment" class="setting-input" placeholder="What did you accomplish in this session? (Optional)"></textarea>
            <button class="modal-btn" id="modalBtn">START NEXT PHASE</button>
        </div>
    </div>

    <script>
        // === DOM Elements ===
        const taskInput = document.getElementById('taskInput');
        const taskPomsInput = document.getElementById('taskPoms');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const taskList = document.getElementById('taskList');
        const taskEmptyState = document.getElementById('taskEmptyState');
        
        // NEW: Tomorrow's Task Elements
        const taskInputTomorrow = document.getElementById('taskInputTomorrow');
        const taskPomsTomorrow = document.getElementById('taskPomsTomorrow');
        const addTaskTomorrowBtn = document.getElementById('addTaskTomorrowBtn');
        const taskListTomorrow = document.getElementById('taskListTomorrow');
        const taskTomorrowEmptyState = document.getElementById('taskTomorrowEmptyState');
        
        const downloadLogBtn = document.getElementById('downloadLogBtn');
        const downloadWeeklyLogBtn = document.getElementById('downloadWeeklyLogBtn');
        
        // Single Day History
        const historyDateInput = document.getElementById('historyDate');
        const viewHistoryBtn = document.getElementById('viewHistoryBtn');
        const historyDisplay = document.getElementById('historyDisplay');
        
        // Historical Stats
        const historyStartDateInput = document.getElementById('historyStartDate');
        const historyEndDateInput = document.getElementById('historyEndDate');
        const historyStatsMessage = document.getElementById('historyStatsMessage');
        
        // AI Insights
        const getInsightsBtn = document.getElementById('getInsightsBtn');
        const aiInsightsDisplay = document.getElementById('aiInsightsDisplay');
        const apiKey = "AIzaSyBT9IN5PiyqaWBdM9NekDg5d-5fWDuhZnE"; // Per instruction, leave empty.
        
        // Modal comment box
        const sessionCommentInput = document.getElementById('sessionComment');

        // === Settings ===
        let focusDuration = 25; // minutes
        let breakDuration = 5; // minutes
        let sessionsPerCycle = 2;

        // === State ===
        let currentMode = 'focus'; // 'focus' or 'break'
        let currentSession = 1;
        let timeRemaining = focusDuration * 60; // seconds
        let totalTime = focusDuration * 60;
        let timerInterval = null;
        let isRunning = false;
        let notificationInterval = null;
        let wakeLock = null;
        
        // Task State
        let tasks = []; // { id: string, text: string, totalPoms: number, completedPoms: number, comments: [] }
        let completedToday = []; // Same object structure
        let tasksForTomorrow = []; // NEW: Tomorrow's tasks

        // Stats
        let completedSessions = 0;
        let totalFocusMinutes = 0;
        
        // History Date Range State
        let historyStartDate;
        let historyEndDate;
        
        // Chart instances
        let taskChartInstance = null;
        let historyTaskChartInstance = null; 

        // === Audio ===
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(frequency, duration) {
            try {
                if (!audioContext) return;
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.error("Error playing sound: ", e);
            }
        }

        function playFocusStartSound() { playSound(523.25, 0.15); setTimeout(() => playSound(659.25, 0.15), 150); setTimeout(() => playSound(783.99, 0.2), 300); setTimeout(() => playSound(1046.50, 0.25), 450); }
        function playFocusEndSound() { playSound(1046.50, 0.1); setTimeout(() => playSound(1174.66, 0.1), 100); setTimeout(() => playSound(1318.51, 0.1), 200); setTimeout(() => playSound(1567.98, 0.2), 300); setTimeout(() => playSound(1567.98, 0.1), 500); setTimeout(() => playSound(1318.51, 0.3), 600); }
        function playBreakStartSound() { playSound(880, 0.2); setTimeout(() => playSound(783.99, 0.2), 200); setTimeout(() => playSound(659.25, 0.2), 400); setTimeout(() => playSound(523.25, 0.3), 600); }
        function playBreakEndSound() { playSound(659.25, 0.15); setTimeout(() => playSound(659.25, 0.15), 200); setTimeout(() => playSound(783.99, 0.2), 400); setTimeout(() => playSound(1046.50, 0.25), 600); }
        function playAlertLoop() { playSound(1000, 0.3); setTimeout(() => playSound(1200, 0.3), 400); }

        // --- Wake Lock (Keep Screen On) ---
        async function requestWakeLock() { 
            try { 
                if ('wakeLock' in navigator) { 
                    wakeLock = await navigator.wakeLock.request('screen'); 
                    console.log('Wake Lock active'); 
                    wakeLock.addEventListener('release', () => console.log('Wake Lock released')); 
                } 
            } catch (err) { 
                console.log('Wake Lock error:', err); 
            } 
        }
        function releaseWakeLock() { 
            if (wakeLock !== null) { 
                wakeLock.release(); 
                wakeLock = null; 
            } 
        }

        // --- Timer Controls ---
        function start() { 
            if (isRunning) return;
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            isRunning = true; 
            timerInterval = setInterval(updateTimer, 1000); 
            requestWakeLock(); 
            document.getElementById('startBtn').style.display = 'none'; 
            document.getElementById('stopBtn').style.display = 'flex'; 
            if (currentMode === 'focus') { 
                playFocusStartSound(); 
            } else { 
                playBreakStartSound(); 
            } 
        }
        
        function stop() { 
            if (!isRunning) return;
            isRunning = false; 
            clearInterval(timerInterval); 
            releaseWakeLock(); 
            document.getElementById('startBtn').style.display = 'flex'; 
            document.getElementById('stopBtn').style.display = 'none'; 
            playSound(400, 0.1); 
        }
        
        function reset() {
            stop();
            currentMode = 'focus';
            currentSession = 1;
            timeRemaining = focusDuration * 60;
            totalTime = focusDuration * 60;
            updateDisplay();
            updateModeDisplay();
            updateSessionDisplay();
            playSound(500, 0.2);
        }

        // --- Timer Logic ---
        function updateTimer() { 
            timeRemaining--; 
            if (timeRemaining <= 0) { 
                completePhase(); 
            } 
            updateDisplay(); 
        }

        function completePhase() {
            stop();
            notificationInterval = setInterval(playAlertLoop, 3000);
            playAlertLoop();
            
            if (currentMode === 'focus') {
                // Focus session ended
                playFocusEndSound();
                completedSessions++;
                totalFocusMinutes += focusDuration;
                
                if (currentSession >= sessionsPerCycle) {
                    showPhaseCompleteModal('üéâ Full Cycle Complete!', 'Congratulations! You completed a full study cycle.\nTake a well-deserved break!', 'break', true); // Show comment box
                    currentSession = 1;
                } else {
                    currentSession++;
                    showPhaseCompleteModal('‚è∞ Focus Complete!', 'Great work! Time for a break.', 'break', true); // Show comment box
                }
            } else {
                // Break ended
                playBreakEndSound();
                
                let nextTaskMessage = 'Ready for the next focus session?';
                if (tasks.length > 0) {
                    nextTaskMessage = `Next task: <br><strong>${tasks[0].text}</strong>`; 
                } else {
                    nextTaskMessage = 'Add a new task to get started!';
                }
                
                showPhaseCompleteModal('‚è∞ Break Over!', nextTaskMessage, 'focus', false); // Hide comment box
            }
        }

        // --- UI Update Functions ---
        function updateDisplay() {
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            document.getElementById('display').textContent = `${pad(minutes)}:${pad(seconds)}`;
            const progress = 1 - (timeRemaining / totalTime);
            const offset = 565 - (565 * progress);
            document.getElementById('progressCircle').style.strokeDashoffset = offset;
            document.title = `${pad(minutes)}:${pad(seconds)} - ${currentMode === 'focus' ? 'Focus' : 'Break'} Time`;
        }

        function updateModeDisplay() {
            const badge = document.getElementById('modeBadge');
            badge.className = `mode-badge ${currentMode}`;
            badge.textContent = currentMode === 'focus' ? 'üéØ Focus Time' : '‚òï Break Time';
            document.body.style.background = currentMode === 'focus' ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' : 'linear-gradient(135deg, #a8e063 0%, #56ab2f 100%)';
        }

        function updateSessionDisplay() {
            document.getElementById('sessionCount').textContent = `${currentSession}/${sessionsPerCycle}`;
            document.getElementById('completedSessions').textContent = completedSessions;
        }

        // --- Stats Functions ---
        
        function updateTodayStats() {
            // Update basic stats
            document.getElementById('totalFocusTime').textContent = `${totalFocusMinutes}m`;
            document.getElementById('totalSessions').textContent = completedSessions;

            // Calculate new stats
            const totalCompletedTasks = completedToday.length;
            const totalIncompleteTasks = tasks.length;
            const totalTasks = totalCompletedTasks + totalIncompleteTasks;
            const completionPercentage = totalTasks === 0 ? 0 : Math.round((totalCompletedTasks / totalTasks) * 100);
            
            const allTasks = [...completedToday, ...tasks];
            const pomsDone = allTasks.reduce((acc, task) => acc + (task.completedPoms || 0), 0);
            const pomsEst = allTasks.reduce((acc, task) => acc + (task.totalPoms || 0), 0);

            // Update DOM
            document.getElementById('statTotalTasks').textContent = totalTasks;
            document.getElementById('statCompletion').textContent = `${completionPercentage}%`;
            document.getElementById('statPomsDone').textContent = pomsDone;
            document.getElementById('statPomsEst').textContent = pomsEst;

            // Update Chart
            updateTodayChart(totalCompletedTasks, totalIncompleteTasks);
        }
        
        function updateTodayChart(completedCount, incompleteCount) {
             try {
                if (taskChartInstance) {
                    taskChartInstance.destroy(); // Destroy old chart
                }
                
                const ctx = document.getElementById('taskChart').getContext('2d');
                taskChartInstance = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Completed', 'Incomplete'],
                        datasets: [{
                            data: [completedCount, incompleteCount],
                            backgroundColor: [
                                'rgba(86, 171, 47, 0.8)',  // Green
                                'rgba(245, 87, 108, 0.8)' // Red
                            ],
                            borderColor: 'rgba(255, 255, 255, 0.1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '70%',
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    color: 'white',
                                    padding: 20,
                                    font: { size: 14 }
                                }
                            },
                            tooltip: {
                                titleFont: { size: 14 },
                                bodyFont: { size: 12 },
                            }
                        }
                    }
                });
            } catch (e) {
                console.error("Error creating today's chart: ", e);
            }
        }

        // --- Settings Panel ---
        function toggleSettings() { 
            document.getElementById('settingsPanel').classList.toggle('hidden'); 
        }

        function saveSettings() {
            const newFocus = parseInt(document.getElementById('focusTime').value);
            const newBreak = parseInt(document.getElementById('breakTime').value);
            const newSessions = parseInt(document.getElementById('sessionsPerCycle').value);
            if (newFocus < 1 || newBreak < 1 || newSessions < 1) { 
                alert('Please enter valid values (minimum 1)'); 
                return; 
            }
            focusDuration = newFocus;
            breakDuration = newBreak;
            sessionsPerCycle = newSessions;
            
            saveStateToLocal(); 
            reset();
            toggleSettings();
            playSound(800, 0.2);
        }

        function pad(number) { return number < 10 ? '0' + number : number; }

        // --- Completion Modal ---
        function handleTaskCompletion(comment) {
            if (tasks.length === 0) return; // No active task
            
            let currentTask = tasks[0];
            currentTask.completedPoms++; // Increment pom count
            
            if (!currentTask.comments) {
                currentTask.comments = [];
            }
            
            if (comment && comment.length > 0) {
                currentTask.comments.push(comment);
            }

            if (currentTask.completedPoms >= currentTask.totalPoms) {
                const completedTask = tasks.shift(); 
                completedToday.push(completedTask); 
            }
            
            renderTasks(); 
            saveStateToLocal(); 
            updateTodayStats(); 
        }
        
        function showPhaseCompleteModal(title, message, nextMode, showCommentBox = false) {
            const modal = document.getElementById('modalOverlay');
            modal.querySelector('#modalTitle').textContent = title;
            modal.querySelector('#modalMessage').innerHTML = message;
            modal.querySelector('#modalIcon').textContent = nextMode === 'focus' ? 'üéØ' : '‚òï';
            
            if (showCommentBox) {
                sessionCommentInput.style.display = 'block';
                sessionCommentInput.value = ''; 
            } else {
                sessionCommentInput.style.display = 'none';
            }
            
            modal.classList.add('show');
            
            modal.querySelector('#modalBtn').onclick = function() {
                clearInterval(notificationInterval);
                
                const comment = sessionCommentInput.value.trim();
                if (showCommentBox) {
                    handleTaskCompletion(comment);
                }
                
                currentMode = nextMode;
                timeRemaining = (nextMode === 'focus' ? focusDuration : breakDuration) * 60;
                totalTime = timeRemaining;
                updateDisplay();
                updateModeDisplay();
                updateSessionDisplay();
                modal.classList.remove('show');
                start();
            };
        }
        
        // === Task Management and Data Persistence ===

        function getTodayDateString(date = new Date()) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // UPDATED: renderTasks to include new buttons
        function renderTasks() {
            if (tasks.length === 0 && completedToday.length === 0) {
                taskList.style.display = 'none';
                taskEmptyState.style.display = 'block';
            } else {
                taskList.style.display = 'block';
                taskEmptyState.style.display = 'none';
            }

            taskList.innerHTML = ''; 
            
            tasks.forEach((task) => {
                const li = document.createElement('li');
                li.className = 'task-item';
                li.setAttribute('draggable', 'true');
                li.dataset.id = task.id; 

                li.innerHTML = `
                    <span class="task-handle">‚ò∞</span>
                    <div class="task-item-details">
                        <span class="task-item-text">${task.text}</span>
                        <span class="task-pom-count">${task.completedPoms} / ${task.totalPoms}</span>
                    </div>
                    <!-- NEW: Postpone/Duplicate Buttons -->
                    <button class="task-btn postpone-task-btn" data-id="${task.id}" title="Postpone to Tomorrow">
                        <svg viewBox="0 0 24 24" fill="currentColor" width="20px" height="20px"><path d="M14 5l7 7-7 7V5zM3 5v14h2V5H3z"></path></svg>
                    </button>
                    <button class="task-btn duplicate-task-btn" data-id="${task.id}" title="Duplicate for Tomorrow">
                         <svg viewBox="0 0 24 24" fill="currentColor" width="20px" height="20px"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>
                    </button>
                    <button class="task-btn delete-task-btn" data-id="${task.id}" title="Delete Task">
                        &times;
                    </button>
                `;
                taskList.appendChild(li);
            });

            completedToday.forEach((task) => {
                const li = document.createElement('li');
                li.className = 'task-item completed';
                li.setAttribute('draggable', 'false');

                li.innerHTML = `
                    <span class="task-handle">‚úÖ</span>
                    <div class="task-item-details">
                        <span class="task-item-text">${task.text}</span>
                        <span class="task-pom-count">${task.completedPoms} / ${task.totalPoms}</span>
                    </div>
                `;
                taskList.appendChild(li);
            });
        }
        
        // NEW: renderTasksForTomorrow
        function renderTasksForTomorrow() {
            if (tasksForTomorrow.length === 0) {
                taskListTomorrow.style.display = 'none';
                taskTomorrowEmptyState.style.display = 'block';
            } else {
                taskListTomorrow.style.display = 'block';
                taskTomorrowEmptyState.style.display = 'none';
            }

            taskListTomorrow.innerHTML = ''; 
            
            tasksForTomorrow.forEach((task) => {
                const li = document.createElement('li');
                li.className = 'task-item';
                li.dataset.id = task.id; 

                li.innerHTML = `
                    <div class="task-item-details">
                        <span class="task-item-text">${task.text}</span>
                        <span class="task-pom-count">${task.completedPoms} / ${task.totalPoms}</span>
                    </div>
                    <button class="task-btn delete-task-btn delete-tomorrow-task-btn" data-id="${task.id}" title="Delete Task">
                        &times;
                    </button>
                `;
                taskListTomorrow.appendChild(li);
            });
        }
        
        function addTask() {
            const taskText = taskInput.value.trim();
            const poms = parseInt(taskPomsInput.value) || 1; 
            
            if (taskText) {
                const newTask = {
                    id: Date.now().toString(),
                    text: taskText,
                    totalPoms: poms,
                    completedPoms: 0,
                    comments: [] 
                };
                tasks.push(newTask);
                taskInput.value = '';
                taskPomsInput.value = ''; 
                renderTasks();
                saveStateToLocal();
                updateTodayStats(); 
            }
        }
        
        // NEW: addTaskForTomorrow
        function addTaskForTomorrow() {
            const taskText = taskInputTomorrow.value.trim();
            const poms = parseInt(taskPomsTomorrow.value) || 1; 
            
            if (taskText) {
                const newTask = {
                    id: Date.now().toString(),
                    text: taskText,
                    totalPoms: poms,
                    completedPoms: 0,
                    comments: [] 
                };
                tasksForTomorrow.push(newTask);
                taskInputTomorrow.value = '';
                taskPomsTomorrow.value = ''; 
                renderTasksForTomorrow();
                saveStateToLocal();
            }
        }
        
        function deleteTask(taskId) {
            tasks = tasks.filter(task => task.id !== taskId);
            renderTasks();
            saveStateToLocal();
            updateTodayStats(); 
        }
        
        // NEW: deleteTaskForTomorrow
        function deleteTaskForTomorrow(taskId) {
            tasksForTomorrow = tasksForTomorrow.filter(task => task.id !== taskId);
            renderTasksForTomorrow();
            saveStateToLocal();
        }
        
        // NEW: postponeTask
        function postponeTask(taskId) {
            const taskIndex = tasks.findIndex(task => task.id === taskId);
            if (taskIndex > -1) {
                const [taskToPostpone] = tasks.splice(taskIndex, 1);
                tasksForTomorrow.push(taskToPostpone);
                
                renderTasks();
                renderTasksForTomorrow();
                saveStateToLocal();
                updateTodayStats();
            }
        }
        
        // NEW: duplicateTask
        function duplicateTask(taskId) {
             const taskToDuplicate = tasks.find(task => task.id === taskId);
             if (taskToDuplicate) {
                 const newTask = {
                     ...taskToDuplicate, // Copy properties
                     id: Date.now().toString(), // New ID
                     completedPoms: 0, // Reset progress
                     comments: [] // Reset comments
                 };
                 tasksForTomorrow.push(newTask);
                 
                 renderTasksForTomorrow();
                 saveStateToLocal();
             }
        }

        // UPDATED: saveStateToLocal
        function saveStateToLocal(dateStr = getTodayDateString()) {
            try {
                // Save today's log
                const dailyLog = {
                    completed: completedToday,
                    incomplete: tasks,
                    stats: { completedSessions, totalFocusMinutes }
                };
                localStorage.setItem(`pomodoro-log-${dateStr}`, JSON.stringify(dailyLog));
                
                // Save current pending tasks
                localStorage.setItem('pomodoro-pending-tasks', JSON.stringify(tasks));
                
                // NEW: Save tomorrow's tasks
                localStorage.setItem('pomodoro-tasks-tomorrow', JSON.stringify(tasksForTomorrow));
                
                // Save settings
                const settings = { focusDuration, breakDuration, sessionsPerCycle };
                localStorage.setItem('pomodoro-settings', JSON.stringify(settings));
                
                // Save last visited date
                localStorage.setItem('pomodoro-last-visited', dateStr);

                // Save history date range
                if (historyStartDate && historyEndDate) {
                    localStorage.setItem('pomodoro-history-start', historyStartDate);
                    localStorage.setItem('pomodoro-history-end', historyEndDate);
                }

            } catch (e) {
                console.error("Failed to save to localStorage: ", e);
            }
        }

        // UPDATED: loadStateFromLocal
        function loadStateFromLocal() {
            try {
                const todayStr = getTodayDateString();
                const lastVisitedStr = localStorage.getItem('pomodoro-last-visited') || todayStr;

                // Load Settings
                const settings = JSON.parse(localStorage.getItem('pomodoro-settings') || '{}');
                if (settings.focusDuration) {
                    focusDuration = settings.focusDuration;
                    breakDuration = settings.breakDuration;
                    sessionsPerCycle = settings.sessionsPerCycle;
                    document.getElementById('focusTime').value = focusDuration;
                    document.getElementById('breakTime').value = breakDuration;
                    document.getElementById('sessionsPerCycle').value = sessionsPerCycle;
                }

                // Handle Day Change
                if (todayStr !== lastVisitedStr) {
                    console.log(`New day detected. Archiving tasks from ${lastVisitedStr}`);
                    const pendingTasksFromYesterday = JSON.parse(localStorage.getItem('pomodoro-pending-tasks') || '[]');
                    const yesterdaysLog = JSON.parse(localStorage.getItem(`pomodoro-log-${lastVisitedStr}`) || '{}');
                    
                    // Archive yesterday's remaining tasks
                    const archiveLog = {
                        completed: yesterdaysLog.completed || [],
                        incomplete: pendingTasksFromYesterday, 
                        stats: yesterdaysLog.stats || { completedSessions: 0, totalFocusMinutes: 0 }
                    };
                    localStorage.setItem(`pomodoro-log-${lastVisitedStr}`, JSON.stringify(archiveLog));
                    
                    // NEW: Load tomorrow's tasks and make them today's tasks
                    tasks = JSON.parse(localStorage.getItem('pomodoro-tasks-tomorrow') || '[]');
                    tasksForTomorrow = []; // Clear tomorrow's list
                    
                    // Reset today's stats
                    completedToday = [];
                    completedSessions = 0;
                    totalFocusMinutes = 0;
                    
                    saveStateToLocal(todayStr); // Save the new state for today

                } else {
                    // Same Day
                    tasks = JSON.parse(localStorage.getItem('pomodoro-pending-tasks') || '[]');
                    tasksForTomorrow = JSON.parse(localStorage.getItem('pomodoro-tasks-tomorrow') || '[]');
                    const todaysLog = JSON.parse(localStorage.getItem(`pomodoro-log-${todayStr}`) || '{}');
                    completedToday = todaysLog.completed || []; 
                    completedSessions = todaysLog.stats?.completedSessions || 0;
                    totalFocusMinutes = todaysLog.stats?.totalFocusMinutes || 0;
                }
                
                // Load History Date Range
                const savedStartDate = localStorage.getItem('pomodoro-history-start');
                const savedEndDate = localStorage.getItem('pomodoro-history-end');

                if (savedStartDate && savedEndDate) {
                    historyStartDate = savedStartDate;
                    historyEndDate = savedEndDate;
                } else {
                    // Default to last 7 days
                    historyEndDate = todayStr;
                    historyStartDate = getTodayDateString(new Date(Date.now() - 6 * 24 * 60 * 60 * 1000));
                }
                historyStartDateInput.value = historyStartDate;
                historyEndDateInput.value = historyEndDate;


            } catch (e) {
                console.error("Failed to load from localStorage: ", e);
                tasks = [];
                completedToday = [];
                tasksForTomorrow = [];
            }

            renderTasks();
            renderTasksForTomorrow(); // NEW
            updateTodayStats(); 
            updateSessionDisplay();
        }
        
        // --- History & Log Functions ---

        function generateAndDownloadLog() {
            const todayStr = getTodayDateString();
            let logContent = `Pomodoro Log for: ${todayStr}\n\n`;
            
            logContent += "‚úÖ Completed Tasks:\n";
            if (completedToday.length > 0) {
                completedToday.forEach(task => {
                    logContent += `- ${task.text} (${task.completedPoms}/${task.totalPoms} Poms)\n`;
                    if (task.comments && task.comments.length > 0) {
                        task.comments.forEach(c => logContent += `      - Comment: ${c}\n`);
                    }
                });
            } else {
                logContent += "- None\n";
            }
            
            logContent += "\nüìù Incomplete Tasks (Pending):\n";
            if (tasks.length > 0) {
                tasks.forEach(task => {
                    logContent += `- ${task.text} (${task.completedPoms}/${task.totalPoms} Poms)\n`;
                    if (task.comments && task.comments.length > 0) {
                        task.comments.forEach(c => logContent += `      - Comment: ${c}\n`);
                    }
                });
            } else {
                logContent += "- None\n";
            }
            
            // NEW: Include tomorrow's tasks in log
            logContent += "\nüóìÔ∏è Tasks Planned for Tomorrow:\n";
            if (tasksForTomorrow.length > 0) {
                tasksForTomorrow.forEach(task => {
                    logContent += `- ${task.text} (${task.completedPoms}/${task.totalPoms} Poms)\n`;
                });
            } else {
                logContent += "- None\n";
            }

            logContent += "\nüìä Stats:\n";
            logContent += `- Total Focus Time: ${totalFocusMinutes} minutes\n`;
            logContent += `- Completed Sessions: ${completedSessions}\n`;
            
            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pomodoro-log-${todayStr}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function generateAndDownloadWeeklyLog() {
            let logContent = `Weekly Pomodoro Summary\n`;
            logContent += `Week of: ${getTodayDateString(new Date(Date.now() - 6 * 24 * 60 * 60 * 1000))} to ${getTodayDateString()}\n`;
            logContent += "========================================\n\n";

            let totalPoms = 0;
            let totalFocus = 0;

            for (let i = 6; i >= 0; i--) { 
                const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000);
                const dateStr = getTodayDateString(date);
                const logData = JSON.parse(localStorage.getItem(`pomodoro-log-${dateStr}`) || 'null');
                
                logContent += `--- ${dateStr} ---\n`;
                if (logData) {
                    logContent += "  ‚úÖ Completed:\n";
                    if (logData.completed && logData.completed.length > 0) {
                        logData.completed.forEach(task => {
                            logContent += `    - ${task.text} (${task.completedPoms}/${task.totalPoms} Poms)\n`;
                            if (task.comments && task.comments.length > 0) {
                                task.comments.forEach(c => logContent += `        - Comment: ${c}\n`);
                            }
                        });
                    } else {
                        logContent += "    - None\n";
                    }
                    
                    logContent += "  üìù Incomplete:\n";
                     if (logData.incomplete && logData.incomplete.length > 0) {
                        logData.incomplete.forEach(task => {
                            logContent += `    - ${task.text} (${task.completedPoms}/${task.totalPoms} Poms)\n`;
                            if (task.comments && task.comments.length > 0) {
                                task.comments.forEach(c => logContent += `        - Comment: ${c}\n`);
                            }
                        });
                    } else {
                        logContent += "    - None\n";
                    }
                    if (logData.stats) {
                        logContent += `\n  üìä Daily Stats: ${logData.stats.completedSessions} sessions, ${logData.stats.totalFocusMinutes} min focus\n`;
                        totalPoms += logData.stats.completedSessions;
                        totalFocus += logData.stats.totalFocusMinutes;
                    }

                } else {
                    logContent += "  (No data logged)\n";
                }
                logContent += "\n";
            }

            logContent += "========================================\n";
            logContent += `Weekly Total Sessions: ${totalPoms}\n`;
            logContent += `Weekly Total Focus Time: ${totalFocus} minutes\n`;

            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pomodoro-weekly-summary-${getTodayDateString()}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function viewHistory() {
            const dateStr = historyDateInput.value;
            if (!dateStr) {
                historyDisplay.innerHTML = `<p>Please select a date.</p>`;
                return;
            }

            let logData = null;
            try {
                logData = JSON.parse(localStorage.getItem(`pomodoro-log-${dateStr}`) || 'null');
            } catch (e) {
                console.error("Failed to parse history data: ", e);
                historyDisplay.innerHTML = `<p>Error loading data for ${dateStr}.</p>`;
                return;
            }

            if (!logData) {
                historyDisplay.innerHTML = `<p>No data found for ${dateStr}.</p>`;
                return;
            }
            
            let historyHTML = `<h4>Log for ${dateStr}</h4>`;
            
            historyHTML += `<h5>‚úÖ Completed Tasks: (${logData.completed ? logData.completed.length : 0})</h5>`;
            if (logData.completed && logData.completed.length > 0) {
                historyHTML += '<ul>';
                logData.completed.forEach(task => {
                    historyHTML += `<li>${task.text} (${task.completedPoms}/${task.totalPoms})`;
                    if (task.comments && task.comments.length > 0) {
                        historyHTML += `<ul class="comment-list">`;
                        task.comments.forEach(c => historyHTML += `<li>${c}</li>`);
                        historyHTML += `</ul>`;
                    }
                    historyHTML += `</li>`;
                });
                historyHTML += '</ul>';
            } else {
                historyHTML += `<p>No tasks were completed.</p>`;
            }

            historyHTML += `<h5 style="margin-top: 15px;">üìù Incomplete Tasks: (${logData.incomplete ? logData.incomplete.length : 0})</h5>`;
            if (logData.incomplete && logData.incomplete.length > 0) {
                historyHTML += '<ul>';
                logData.incomplete.forEach(task => {
                    historyHTML += `<li>${task.text} (${task.completedPoms}/${task.totalPoms})`;
                     if (task.comments && task.comments.length > 0) {
                        historyHTML += `<ul class="comment-list">`;
                        task.comments.forEach(c => historyHTML += `<li>${c}</li>`);
                        historyHTML += `</ul>`;
                    }
                    historyHTML += `</li>`;
                });
                historyHTML += '</ul>';
            } else {
                 historyHTML += `<p>No tasks were left incomplete.</p>`;
            }
            
            historyDisplay.innerHTML = historyHTML;
        }

        function getAggregatedData(startDateStr, endDateStr) {
            let aggFocus = 0;
            let aggSessions = 0;
            let aggCompletedTasks = [];
            let aggIncompleteTasks = [];
            
            let currentDate = new Date(startDateStr);
            currentDate.setHours(0, 0, 0, 0); 
            const endDate = new Date(endDateStr);
            endDate.setHours(0, 0, 0, 0);

            let dayCount = 0;
            const todayStrForLoop = getTodayDateString(); // Get today's date once

            while (currentDate <= endDate) {
                const dateStr = getTodayDateString(currentDate);
                let logData = JSON.parse(localStorage.getItem(`pomodoro-log-${dateStr}`) || 'null');
                
                // If the date is today, we need to use the live data, not the saved log
                if (dateStr === todayStrForLoop) {
                    logData = {
                        completed: completedToday,
                        incomplete: tasks,
                        stats: { completedSessions, totalFocusMinutes }
                    };
                }
                
                if (logData) {
                    aggFocus += logData.stats?.totalFocusMinutes || 0;
                    aggSessions += logData.stats?.completedSessions || 0;
                    aggCompletedTasks.push(...(logData.completed || []));
                    
                    // Only the *last* day's incomplete tasks matter for the final "incomplete" count
                    if (dateStr === getTodayDateString(endDate)) {
                         aggIncompleteTasks = logData.incomplete || [];
                    }
                }
                currentDate.setDate(currentDate.getDate() + 1);
                dayCount++;
                if (dayCount > 365) break; 
            }
            
            return { aggFocus, aggSessions, aggCompletedTasks, aggIncompleteTasks };
        }

        function generateHistoricalStats() {
            const startDateStr = historyStartDateInput.value;
            const endDateStr = historyEndDateInput.value;
            
            if (!startDateStr || !endDateStr) {
                historyStatsMessage.textContent = "Please select a start and end date.";
                return;
            }
            
            historyStartDate = startDateStr;
            historyEndDate = endDateStr;
            saveStateToLocal();
            
            const { aggFocus, aggSessions, aggCompletedTasks, aggIncompleteTasks } = getAggregatedData(startDateStr, endDateStr);

            // Calculate stats
            const totalCompleted = aggCompletedTasks.length;
            const totalIncomplete = aggIncompleteTasks.length; 
            const totalTasks = totalCompleted + totalIncomplete;
            const completionPerc = totalTasks === 0 ? 0 : Math.round((totalCompleted / totalTasks) * 100);

            const allAggTasks = [...aggCompletedTasks, ...aggIncompleteTasks];
            const pomsDone = allAggTasks.reduce((acc, task) => acc + (task.completedPoms || 0), 0);
            const pomsEst = allAggTasks.reduce((acc, task) => acc + (task.totalPoms || 0), 0);

            // Update DOM
            if (totalTasks === 0 && aggSessions === 0) {
                 historyStatsMessage.textContent = `No data found from ${startDateStr} to ${endDateStr}.`;
            } else {
                 historyStatsMessage.textContent = `Showing stats from ${startDateStr} to ${endDateStr}.`;
            }
            
            document.getElementById('histStatFocusTime').textContent = `${aggFocus}m`;
            document.getElementById('histStatSessions').textContent = aggSessions;
            document.getElementById('histStatCompletion').textContent = `${completionPerc}%`;
            document.getElementById('histStatTotalTasks').textContent = totalTasks;
            document.getElementById('histStatPomsDone').textContent = pomsDone;
            document.getElementById('histStatPomsEst').textContent = pomsEst;

            // Update Chart
            updateHistoryChart(totalCompleted, totalIncomplete);
        }

        function updateHistoryChart(completedCount, incompleteCount) {
            try {
                if (historyTaskChartInstance) {
                    historyTaskChartInstance.destroy(); // Destroy old chart
                }
                
                const ctx = document.getElementById('historyTaskChart').getContext('2d');
                historyTaskChartInstance = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Completed', 'Incomplete'],
                        datasets: [{
                            data: [completedCount, incompleteCount],
                            backgroundColor: [
                                'rgba(86, 171, 47, 0.8)',  // Green
                                'rgba(245, 87, 108, 0.8)' // Red
                            ],
                            borderColor: 'rgba(255, 255, 255, 0.1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '70%',
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    color: 'white',
                                    padding: 20,
                                    font: { size: 14 }
                                }
                            },
                            tooltip: {
                                titleFont: { size: 14 },
                                bodyFont: { size: 12 },
                            }
                        }
                    }
                });
            } catch (e) {
                console.error("Error creating history chart: ", e);
            }
        }
        
        // --- AI Insight Functions ---
        
        async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.warn(`Attempt ${i + 1} failed. Retrying in ${delay}ms...`);
                    if (i === retries - 1) throw error; 
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2; 
                }
            }
        }

        function parseSimpleMarkdown(text) {
            let html = text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') 
                .replace(/\*(.*?)\*/g, '<em>$1</em>');     
            
            html = html.split('\n').map(line => {
                if (line.startsWith('* ')) {
                    return `<li>${line.substring(2)}</li>`;
                }
                return line;
            }).join('\n');

            html = html.replace(/<\/li>\n<li>/g, '</li><li>');   
            html = html.replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>'); 
            
            html = html.split('\n').map(part => {
                if (part.startsWith('<ul>') || part.startsWith('<li>')) return part;
                return part.replace(/\n/g, '<br>');
            }).join('\n');
            
            html = html.replace(/<br><ul>/g, '<ul>');
            html = html.replace(/<\/ul><br>/g, '</ul>');
            html = html.replace(/\n/g, '<br>');

            return html;
        }

        async function getAIInsights() {
            aiInsightsDisplay.innerHTML = '<div class="spinner"></div>';
            getInsightsBtn.disabled = true;

            try {
                // 1. Get data from the selected date range
                const { aggCompletedTasks, aggIncompleteTasks } = getAggregatedData(
                    historyStartDateInput.value,
                    historyEndDateInput.value
                );
                
                const allTasks = [...aggCompletedTasks, ...aggIncompleteTasks];
                if (allTasks.length === 0) {
                    aiInsightsDisplay.innerHTML = "Not enough data to analyze. Please select a range with logged tasks.";
                    getInsightsBtn.disabled = false;
                    return;
                }
                
                // 2. Format the data for the AI
                const allComments = allTasks.flatMap(task => task.comments || []).filter(c => c);

                const dataSummary = {
                    completedTasks: aggCompletedTasks.map(task => task.text),
                    incompleteTasks: aggIncompleteTasks.map(task => task.text),
                    sessionComments: allComments, 
                    totalPomodorosCompleted: allTasks.reduce((acc, task) => acc + (task.completedPoms || 0), 0),
                    totalPomodorosEstimated: allTasks.reduce((acc, task) => acc + (task.totalPoms || 0), 0),
                    totalFocusSessions: allTasks.reduce((acc, task) => acc + (task.completedPoms || 0), 0)
                };

                // 3. Define Prompts
                const systemPrompt = "You are a friendly, encouraging, and sharp-eyed study coach. Your goal is to analyze a student's task list and session comments from their Pomodoro timer app, identify their main topics of study, and provide actionable insights. Use Google Search to understand *what* the topics are (e.g., 'Andrej Karpathy AI course' is a deep learning topic). Keep your response concise, friendly, and formatted in basic Markdown (use **bold**, *italics*, and `*` for lists). Do not use headers.";

                const userQuery = `Here is my study data for the period: ${JSON.stringify(dataSummary)}. 
                
Please analyze my focus areas (like 'Andrej Karpathy AI course' which you should identify as an AI topic), note my most common topics, and give me one or two actionable insights or suggestions based on my task list AND my session comments. The comments show what I learned or struggled with.`;
                
                // 4. Construct API Payload
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                const payload = {
                    contents: [{ "parts": [{ "text": userQuery }] }],
                    systemInstruction: { "parts": [{ "text": systemPrompt }] },
                    tools: [{ "google_search": {} }] // Use Google Search
                };

                // 5. Fetch with retry
                const result = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                // 6. Display result
                const aiText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (aiText) {
                    aiInsightsDisplay.innerHTML = parseSimpleMarkdown(aiText);
                } else {
                    throw new Error("No content in AI response.");
                }

            } catch (error) {
                console.error("Error getting AI insights: ", error);
                aiInsightsDisplay.innerHTML = "Sorry, I couldn't get insights right now. Please check the console and try again.";
            } finally {
                getInsightsBtn.disabled = false;
            }
        }


        // --- Event Listeners ---
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('stopBtn').addEventListener('click', stop);
        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('settingsBtn').addEventListener('click', toggleSettings);
        document.getElementById('saveBtn').addEventListener('click', saveSettings);
        
        // Task Listeners
        addTaskBtn.addEventListener('click', addTask);
        taskInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTask(); });
        taskPomsInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTask(); });
        
        taskList.addEventListener('click', (e) => {
            const targetBtn = e.target.closest('button');
            if (!targetBtn) return;
            
            const taskId = targetBtn.dataset.id;
            
            if (targetBtn.classList.contains('delete-task-btn')) {
                deleteTask(taskId);
            } else if (targetBtn.classList.contains('postpone-task-btn')) {
                postponeTask(taskId);
            } else if (targetBtn.classList.contains('duplicate-task-btn')) {
                duplicateTask(taskId);
            }
        });
        
        // NEW: Tomorrow's Task Listeners
        addTaskTomorrowBtn.addEventListener('click', addTaskForTomorrow);
        taskInputTomorrow.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTaskForTomorrow(); });
        taskPomsTomorrow.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTaskForTomorrow(); });
        
        taskListTomorrow.addEventListener('click', (e) => {
            const targetBtn = e.target.closest('button');
            if (targetBtn && targetBtn.classList.contains('delete-tomorrow-task-btn')) {
                deleteTaskForTomorrow(targetBtn.dataset.id);
            }
        });
        
        
        // History Listeners
        downloadLogBtn.addEventListener('click', generateAndDownloadLog);
        downloadWeeklyLogBtn.addEventListener('click', generateAndDownloadWeeklyLog);
        viewHistoryBtn.addEventListener('click', viewHistory);

        // Historical Stats Listeners
        historyStartDateInput.addEventListener('change', generateHistoricalStats);
        historyEndDateInput.addEventListener('change', generateHistoricalStats);
        
        // AI Insight Listener
        getInsightsBtn.addEventListener('click', getAIInsights);

        // --- Keyboard shortcuts ---
        document.addEventListener('keydown', (e) => {
            // NEW: Ignore shortcuts if typing in any input
            if (['taskInput', 'taskPomsInput', 'sessionCommentInput', 'taskInputTomorrow', 'taskPomsTomorrow'].includes(document.activeElement.id)) {
                return;
            }
            
            if (e.code === 'Space') { e.preventDefault(); isRunning ? stop() : start(); } 
            else if (e.code === 'KeyR') { reset(); } 
            else if (e.code === 'KeyS') { toggleSettings(); }
        });

        // Handle tab visibility change
        document.addEventListener('visibilitychange', () => { if (!document.hidden && isRunning) requestWakeLock(); });
        let keepAliveInterval = setInterval(() => { if (isRunning) document.title = document.title; }, 1000);
        
        // --- Drag and Drop ---
        let dragStartId;
        
        function dragStart(e) {
            const taskItem = e.target.closest('.task-item');
            if (taskItem && !taskItem.classList.contains('completed')) {
                // Prevent drag if clicking a button
                if (e.target.closest('.task-btn')) {
                    e.preventDefault(); 
                    return;
                }
                dragStartId = taskItem.dataset.id; 
                taskItem.classList.add('dragging'); 
            } else {
                e.preventDefault();
            }
        }
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.task-item:not(.completed):not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        
        function dragOver(e) {
            e.preventDefault(); 
            const draggingItem = document.querySelector('.dragging');
            if (!draggingItem) return;

            const afterElement = getDragAfterElement(taskList, e.clientY);
            if (afterElement == null) {
                const firstCompleted = taskList.querySelector('.task-item.completed');
                if (firstCompleted) {
                    taskList.insertBefore(draggingItem, firstCompleted);
                } else {
                    taskList.appendChild(draggingItem);
                }
            } else {
                taskList.insertBefore(draggingItem, afterElement);
            }
        }

        function drop(e) {
            const draggingItem = taskList.querySelector('.dragging');
            if (draggingItem) {
                draggingItem.classList.remove('dragging');
                
                const newIdOrder = [...taskList.querySelectorAll('.task-item:not(.completed)')]
                                    .map(li => li.dataset.id);
                
                tasks.sort((a, b) => newIdOrder.indexOf(a.id) - newIdOrder.indexOf(b.id));
                
                renderTasks(); 
                saveStateToLocal();
            }
        }
        
        taskList.addEventListener('dragstart', dragStart);
        taskList.addEventListener('dragover', dragOver);
        taskList.addEventListener('drop', drop);
        taskList.addEventListener('dragend', () => {
             const draggingItem = taskList.querySelector('.dragging');
            if (draggingItem) {
                draggingItem.classList.remove('dragging');
            }
        });


        // --- Initialize App ---
        function init() {
            loadStateFromLocal(); 
            reset(); 
            generateHistoricalStats(); // Load default history stats on startup
        }

        init();
    </script>
</body>
</html>


